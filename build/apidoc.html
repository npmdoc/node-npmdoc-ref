<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/TooTallNate/ref#readme"

    >ref (v1.3.4)</a>
</h1>
<h4>Turn Buffer instances into "pointers"</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.ref">module ref</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref">
            function <span class="apidocSignatureSpan"></span>ref
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref._attach">
            function <span class="apidocSignatureSpan">ref.</span>_attach
            <span class="apidocSignatureSpan">(buf, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref._reinterpret">
            function <span class="apidocSignatureSpan">ref.</span>_reinterpret
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref._reinterpretUntilZeros">
            function <span class="apidocSignatureSpan">ref.</span>_reinterpretUntilZeros
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref._writeObject">
            function <span class="apidocSignatureSpan">ref.</span>_writeObject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref._writePointer">
            function <span class="apidocSignatureSpan">ref.</span>_writePointer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.address">
            function <span class="apidocSignatureSpan">ref.</span>address
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.alloc">
            function <span class="apidocSignatureSpan">ref.</span>alloc
            <span class="apidocSignatureSpan">(_type, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.allocCString">
            function <span class="apidocSignatureSpan">ref.</span>allocCString
            <span class="apidocSignatureSpan">(string, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.coerceType">
            function <span class="apidocSignatureSpan">ref.</span>coerceType
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.deref">
            function <span class="apidocSignatureSpan">ref.</span>deref
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.derefType">
            function <span class="apidocSignatureSpan">ref.</span>derefType
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.get">
            function <span class="apidocSignatureSpan">ref.</span>get
            <span class="apidocSignatureSpan">(buffer, offset, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.getType">
            function <span class="apidocSignatureSpan">ref.</span>getType
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.hexAddress">
            function <span class="apidocSignatureSpan">ref.</span>hexAddress
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.isNull">
            function <span class="apidocSignatureSpan">ref.</span>isNull
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.readCString">
            function <span class="apidocSignatureSpan">ref.</span>readCString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.readInt64">
            function <span class="apidocSignatureSpan">ref.</span>readInt64
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.readInt64BE">
            function <span class="apidocSignatureSpan">ref.</span>readInt64BE
            <span class="apidocSignatureSpan">(buffer, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.readInt64LE">
            function <span class="apidocSignatureSpan">ref.</span>readInt64LE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.readObject">
            function <span class="apidocSignatureSpan">ref.</span>readObject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.readPointer">
            function <span class="apidocSignatureSpan">ref.</span>readPointer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.readUInt64">
            function <span class="apidocSignatureSpan">ref.</span>readUInt64
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.readUInt64BE">
            function <span class="apidocSignatureSpan">ref.</span>readUInt64BE
            <span class="apidocSignatureSpan">(buffer, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.readUInt64LE">
            function <span class="apidocSignatureSpan">ref.</span>readUInt64LE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.refType">
            function <span class="apidocSignatureSpan">ref.</span>refType
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.reinterpret">
            function <span class="apidocSignatureSpan">ref.</span>reinterpret
            <span class="apidocSignatureSpan">(buffer, size, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.reinterpretUntilZeros">
            function <span class="apidocSignatureSpan">ref.</span>reinterpretUntilZeros
            <span class="apidocSignatureSpan">(buffer, size, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.set">
            function <span class="apidocSignatureSpan">ref.</span>set
            <span class="apidocSignatureSpan">(buffer, offset, value, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.writeCString">
            function <span class="apidocSignatureSpan">ref.</span>writeCString
            <span class="apidocSignatureSpan">(buffer, offset, string, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.writeInt64">
            function <span class="apidocSignatureSpan">ref.</span>writeInt64
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.writeInt64BE">
            function <span class="apidocSignatureSpan">ref.</span>writeInt64BE
            <span class="apidocSignatureSpan">(buffer, offset, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.writeInt64LE">
            function <span class="apidocSignatureSpan">ref.</span>writeInt64LE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.writeObject">
            function <span class="apidocSignatureSpan">ref.</span>writeObject
            <span class="apidocSignatureSpan">(buf, offset, obj, persistent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.writePointer">
            function <span class="apidocSignatureSpan">ref.</span>writePointer
            <span class="apidocSignatureSpan">(buf, offset, ptr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.writeUInt64">
            function <span class="apidocSignatureSpan">ref.</span>writeUInt64
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.writeUInt64BE">
            function <span class="apidocSignatureSpan">ref.</span>writeUInt64BE
            <span class="apidocSignatureSpan">(buffer, offset, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.writeUInt64LE">
            function <span class="apidocSignatureSpan">ref.</span>writeUInt64LE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ref.</span>NULL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ref.</span>NULL_POINTER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ref.</span>alignof</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ref.</span>sizeof</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ref.</span>types</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ref.</span>endianness</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ref.</span>path</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ref.ref">module ref.ref</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.ref">
            function <span class="apidocSignatureSpan">ref.</span>ref
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref._attach">
            function <span class="apidocSignatureSpan">ref.ref.</span>_attach
            <span class="apidocSignatureSpan">(buf, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref._reinterpret">
            function <span class="apidocSignatureSpan">ref.ref.</span>_reinterpret
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref._reinterpretUntilZeros">
            function <span class="apidocSignatureSpan">ref.ref.</span>_reinterpretUntilZeros
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref._writeObject">
            function <span class="apidocSignatureSpan">ref.ref.</span>_writeObject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref._writePointer">
            function <span class="apidocSignatureSpan">ref.ref.</span>_writePointer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.address">
            function <span class="apidocSignatureSpan">ref.ref.</span>address
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.alloc">
            function <span class="apidocSignatureSpan">ref.ref.</span>alloc
            <span class="apidocSignatureSpan">(_type, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.allocCString">
            function <span class="apidocSignatureSpan">ref.ref.</span>allocCString
            <span class="apidocSignatureSpan">(string, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.coerceType">
            function <span class="apidocSignatureSpan">ref.ref.</span>coerceType
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.deref">
            function <span class="apidocSignatureSpan">ref.ref.</span>deref
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.derefType">
            function <span class="apidocSignatureSpan">ref.ref.</span>derefType
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.get">
            function <span class="apidocSignatureSpan">ref.ref.</span>get
            <span class="apidocSignatureSpan">(buffer, offset, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.getType">
            function <span class="apidocSignatureSpan">ref.ref.</span>getType
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.hexAddress">
            function <span class="apidocSignatureSpan">ref.ref.</span>hexAddress
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.isNull">
            function <span class="apidocSignatureSpan">ref.ref.</span>isNull
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.readCString">
            function <span class="apidocSignatureSpan">ref.ref.</span>readCString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.readInt64">
            function <span class="apidocSignatureSpan">ref.ref.</span>readInt64
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.readInt64BE">
            function <span class="apidocSignatureSpan">ref.ref.</span>readInt64BE
            <span class="apidocSignatureSpan">(buffer, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.readInt64LE">
            function <span class="apidocSignatureSpan">ref.ref.</span>readInt64LE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.readObject">
            function <span class="apidocSignatureSpan">ref.ref.</span>readObject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.readPointer">
            function <span class="apidocSignatureSpan">ref.ref.</span>readPointer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.readUInt64">
            function <span class="apidocSignatureSpan">ref.ref.</span>readUInt64
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.readUInt64BE">
            function <span class="apidocSignatureSpan">ref.ref.</span>readUInt64BE
            <span class="apidocSignatureSpan">(buffer, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.readUInt64LE">
            function <span class="apidocSignatureSpan">ref.ref.</span>readUInt64LE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.refType">
            function <span class="apidocSignatureSpan">ref.ref.</span>refType
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.reinterpret">
            function <span class="apidocSignatureSpan">ref.ref.</span>reinterpret
            <span class="apidocSignatureSpan">(buffer, size, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.reinterpretUntilZeros">
            function <span class="apidocSignatureSpan">ref.ref.</span>reinterpretUntilZeros
            <span class="apidocSignatureSpan">(buffer, size, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.set">
            function <span class="apidocSignatureSpan">ref.ref.</span>set
            <span class="apidocSignatureSpan">(buffer, offset, value, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.writeCString">
            function <span class="apidocSignatureSpan">ref.ref.</span>writeCString
            <span class="apidocSignatureSpan">(buffer, offset, string, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.writeInt64">
            function <span class="apidocSignatureSpan">ref.ref.</span>writeInt64
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.writeInt64BE">
            function <span class="apidocSignatureSpan">ref.ref.</span>writeInt64BE
            <span class="apidocSignatureSpan">(buffer, offset, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.writeInt64LE">
            function <span class="apidocSignatureSpan">ref.ref.</span>writeInt64LE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.writeObject">
            function <span class="apidocSignatureSpan">ref.ref.</span>writeObject
            <span class="apidocSignatureSpan">(buf, offset, obj, persistent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.writePointer">
            function <span class="apidocSignatureSpan">ref.ref.</span>writePointer
            <span class="apidocSignatureSpan">(buf, offset, ptr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.writeUInt64">
            function <span class="apidocSignatureSpan">ref.ref.</span>writeUInt64
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.writeUInt64BE">
            function <span class="apidocSignatureSpan">ref.ref.</span>writeUInt64BE
            <span class="apidocSignatureSpan">(buffer, offset, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ref.ref.writeUInt64LE">
            function <span class="apidocSignatureSpan">ref.ref.</span>writeUInt64LE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ref.ref.</span>NULL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ref.ref.</span>NULL_POINTER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ref.ref.</span>alignof</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ref.ref.</span>sizeof</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ref.ref.</span>types</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ref.ref.</span>endianness</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ref.ref.</span>path</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ref" id="apidoc.module.ref">module ref</a></h1>


    <h2>
        <a href="#apidoc.element.ref.ref" id="apidoc.element.ref.ref">
        function <span class="apidocSignatureSpan"></span>ref
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ref(buffer) {
  debug(&#x27;creating a reference to buffer&#x27;, buffer)
  var type = exports.refType(exports.getType(buffer))
  return exports.alloc(type, buffer)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// now we can dereference to get the &#x22;meaningful&#x22; value
console.log(buf.deref())  // ← 12345


// you can also get references to the original buffer if you need it.
// this buffer could be thought of as an &#x22;int **&#x22;
var one = buf.<span class="apidocCodeKeywordSpan">ref</span>()

// and you can dereference all the way back down to an int
console.log(one.deref().deref())  // ← 12345
```

See the [full API Docs][docs] for more examples.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref._attach" id="apidoc.element.ref._attach">
        function <span class="apidocSignatureSpan">ref.</span>_attach
        <span class="apidocSignatureSpan">(buf, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _attach(buf, obj) {
  if (!buf._refs) {
    buf._refs = []
  }
  buf._refs.push(obj)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Number} offset The offset on the Buffer to start writing at.
* @param {Object} object The Object to be written into _buffer_.
*/

exports.writeObject = function writeObject (buf, offset, obj, persistent) {
 debug(&#x27;writing Object to buffer&#x27;, buf, offset, obj, persistent)
 exports._writeObject(buf, offset, obj, persistent)
 exports.<span class="apidocCodeKeywordSpan">_attach</span>(buf, obj)
}

/**
* Same as `ref.writePointer()`, except that this version does not attach
* _pointer_ to _buffer_, which is potentially unsafe if the garbage collector
* runs.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref._reinterpret" id="apidoc.element.ref._reinterpret">
        function <span class="apidocSignatureSpan">ref.</span>_reinterpret
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reinterpret() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Number} size The `length` property of the returned Buffer.
* @param {Number} offset The offset of the Buffer to begin from.
* @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and the requested _size_.
*/

exports.reinterpret = function reinterpret (buffer, size, offset) {
 debug(&#x27;reinterpreting buffer to &#x22;%d&#x22; bytes&#x27;, size)
 var rtn = exports.<span class="apidocCodeKeywordSpan">_reinterpret</span>(buffer, size, offset || 0)
 exports._attach(rtn, buffer)
 return rtn
}

/**
* Same as `ref.reinterpretUntilZeros()`, except that this version does not
* attach _buffer_ to the returned Buffer, which is potentially unsafe if the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref._reinterpretUntilZeros" id="apidoc.element.ref._reinterpretUntilZeros">
        function <span class="apidocSignatureSpan">ref.</span>_reinterpretUntilZeros
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reinterpretUntilZeros() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Number} size The number of sequential, aligned `NULL` bytes are required to terminate the buffer.
 * @param {Number} offset The offset of the Buffer to begin from.
 * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and a variable `length` that is terminated by
 _size_ NUL bytes.
 */

exports.reinterpretUntilZeros = function reinterpretUntilZeros (buffer, size, offset) {
  debug(&#x27;reinterpreting buffer to until &#x22;%d&#x22; NULL (0) bytes are found&#x27;, size)
  var rtn = exports.<span class="apidocCodeKeywordSpan">_reinterpretUntilZeros</span>(buffer, size, offset || 0)
  exports._attach(rtn, buffer)
  return rtn
}


// the built-in &#x22;types&#x22;
var types = exports.types = {}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref._writeObject" id="apidoc.element.ref._writeObject">
        function <span class="apidocSignatureSpan">ref.</span>_writeObject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeObject() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Buffer} buffer A Buffer instance to write _object_ to.
* @param {Number} offset The offset on the Buffer to start writing at.
* @param {Object} object The Object to be written into _buffer_.
*/

exports.writeObject = function writeObject (buf, offset, obj, persistent) {
 debug(&#x27;writing Object to buffer&#x27;, buf, offset, obj, persistent)
 exports.<span class="apidocCodeKeywordSpan">_writeObject</span>(buf, offset, obj, persistent)
 exports._attach(buf, obj)
}

/**
* Same as `ref.writePointer()`, except that this version does not attach
* _pointer_ to _buffer_, which is potentially unsafe if the garbage collector
* runs.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref._writePointer" id="apidoc.element.ref._writePointer">
        function <span class="apidocSignatureSpan">ref.</span>_writePointer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writePointer() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Buffer} buffer A Buffer instance to write _pointer to.
* @param {Number} offset The offset on the Buffer to start writing at.
* @param {Buffer} pointer The Buffer instance whose memory address will be written to _buffer_.
*/

exports.writePointer = function writePointer (buf, offset, ptr) {
 debug(&#x27;writing pointer to buffer&#x27;, buf, offset, ptr)
 exports.<span class="apidocCodeKeywordSpan">_writePointer</span>(buf, offset, ptr)
 exports._attach(buf, ptr)
}

/**
* Same as `ref.reinterpret()`, except that this version does not attach
* _buffer_ to the returned Buffer, which is potentially unsafe if the
* garbage collector runs.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.address" id="apidoc.element.ref.address">
        function <span class="apidocSignatureSpan">ref.</span>address
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function address() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// so we can all agree that a buffer with the int value written
// to it could be represented as an &#x22;int *&#x22;
var buf = new Buffer(4)
buf.writeInt32LE(12345, 0)

// first, what is the memory address of the buffer?
console.log(buf.<span class="apidocCodeKeywordSpan">address</span>())  // ← 140362165284824

// using `ref`, you can set the &#x22;type&#x22;, and gain magic abilities!
buf.type = ref.types.int

// now we can dereference to get the &#x22;meaningful&#x22; value
console.log(buf.deref())  // ← 12345
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.alloc" id="apidoc.element.ref.alloc">
        function <span class="apidocSignatureSpan">ref.</span>alloc
        <span class="apidocSignatureSpan">(_type, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function alloc(_type, value) {
  var type = exports.coerceType(_type)
  debug(&#x27;allocating Buffer for type with &#x22;size&#x22;&#x27;, type.size)
  var size
  if (type.indirection === 1) {
    size = type.size
  } else {
    size = exports.sizeof.pointer
  }
  var buffer = new Buffer(size)
  buffer.type = type
  if (arguments.length &#x3e;= 2) {
    debug(&#x27;setting value on allocated buffer&#x27;, value)
    exports.set(buffer, 0, value, type)
  }
  return buffer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Reads a JavaScript Object that has previously been written to the given
* _buffer_ at the given _offset_.
*
* ```
* var obj = { foo: &#x27;bar&#x27; };
* var buf = ref.<span class="apidocCodeKeywordSpan">alloc</span>(&#x27;Object&#x27;, obj);
*
* var obj2 = ref.readObject(buf, 0);
* console.log(obj === obj2);
* true
* ```
*
* @param {Buffer} buffer The buffer to read an Object from.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.allocCString" id="apidoc.element.ref.allocCString">
        function <span class="apidocSignatureSpan">ref.</span>allocCString
        <span class="apidocSignatureSpan">(string, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function allocCString(string, encoding) {
  if (null == string || (Buffer.isBuffer(string) &#x26;&#x26; exports.isNull(string))) {
    return exports.NULL
  }
  var size = Buffer.byteLength(string, encoding) + 1
  var buffer = new Buffer(size)
  exports.writeCString(buffer, 0, string, encoding)
  buffer.type = charPtrType
  return buffer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Returns a new `Buffer` instance with the given String written to it with the
* given encoding (defaults to __&#x27;utf8&#x27;__). The buffer is 1 byte longer than the
* string itself, and is NUL terminated.
*
* ```
* var buf = ref.<span class="apidocCodeKeywordSpan">allocCString</span>(&#x27;hello world&#x27;);
*
* console.log(buf.toString());
* &#x27;hello world\u0000&#x27;
* ```
*
* @param {String} string The JavaScript string to be converted to a C string.
* @param {String} encoding (optional) The encoding to use for the C string. Defaults to __&#x27;utf8&#x27;__.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.coerceType" id="apidoc.element.ref.coerceType">
        function <span class="apidocSignatureSpan">ref.</span>coerceType
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function coerceType(type) {
  var rtn = type
  if (typeof rtn === &#x27;string&#x27;) {
    rtn = exports.types[type]
    if (rtn) return rtn

    // strip whitespace
    rtn = type.replace(/\s+/g, &#x27;&#x27;).toLowerCase()
    if (rtn === &#x27;pointer&#x27;) {
      // legacy &#x22;pointer&#x22; being used :(
      rtn = exports.refType(exports.types.void) // void *
    } else if (rtn === &#x27;string&#x27;) {
      rtn = exports.types.CString // special char * type
    } else {
      var refCount = 0
      rtn = rtn.replace(/\*/g, function () {
        refCount++
        return &#x27;&#x27;
      })
      // allow string names to be passed in
      rtn = exports.types[rtn]
      if (refCount &#x3e; 0) {
        if (!(rtn &#x26;&#x26; &#x27;size&#x27; in rtn &#x26;&#x26; &#x27;indirection&#x27; in rtn)) {
          throw new TypeError(&#x27;could not determine a proper &#x22;type&#x22; from: &#x27; + JSON.stringify(type))
        }
        for (var i = 0; i &#x3c; refCount; i++) {
          rtn = exports.refType(rtn)
        }
      }
    }
  }
  if (!(rtn &#x26;&#x26; &#x27;size&#x27; in rtn &#x26;&#x26; &#x27;indirection&#x27; in rtn)) {
    throw new TypeError(&#x27;could not determine a proper &#x22;type&#x22; from: &#x27; + JSON.stringify(type))
  }
  return rtn
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * ```
 *
 * @param {Object|String} type The &#x22;type&#x22; object to create a reference type from. Strings get coerced first.
 * @return {Object} The new &#x22;type&#x22; object with its `indirection` incremented by 1.
 */

exports.refType = function refType (type) {
var _type = exports.<span class="apidocCodeKeywordSpan">coerceType</span>(type)
var rtn = Object.create(_type)
rtn.indirection++
if (_type.name) {
  Object.defineProperty(rtn, &#x27;name&#x27;, {
    value: _type.name + &#x27;*&#x27;,
    configurable: true,
    enumerable: true,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.deref" id="apidoc.element.ref.deref">
        function <span class="apidocSignatureSpan">ref.</span>deref
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deref(buffer) {
  debug(&#x27;dereferencing buffer&#x27;, buffer)
  return exports.get(buffer)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// first, what is the memory address of the buffer?
console.log(buf.address())  // ← 140362165284824

// using `ref`, you can set the &#x22;type&#x22;, and gain magic abilities!
buf.type = ref.types.int

// now we can dereference to get the &#x22;meaningful&#x22; value
console.log(buf.<span class="apidocCodeKeywordSpan">deref</span>())  // ← 12345


// you can also get references to the original buffer if you need it.
// this buffer could be thought of as an &#x22;int **&#x22;
var one = buf.ref()

// and you can dereference all the way back down to an int
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.derefType" id="apidoc.element.ref.derefType">
        function <span class="apidocSignatureSpan">ref.</span>derefType
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function derefType(type) {
  var _type = exports.coerceType(type)
  if (_type.indirection === 1) {
    throw new Error(&#x27;Cannot create deref\&#x27;d type for type with indirection 1&#x27;)
  }
  var rtn = Object.getPrototypeOf(_type)
  if (rtn.indirection !== _type.indirection - 1) {
    // slow case
    rtn = Object.create(_type)
    rtn.indirection--
  }
  return rtn
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 if (type.indirection === 1) {
   // need to check &#x22;type&#x22;
   return type.get(buffer, offset)
 } else {
   // need to create a deref&#x27;d Buffer
   var size = type.indirection === 2 ? type.size : exports.sizeof.pointer
   var reference = exports.readPointer(buffer, offset, size)
   reference.type = exports.<span class="apidocCodeKeywordSpan">derefType</span>(type)
   return reference
 }
}

/**
* Calls the `set()` function of the Buffer&#x27;s current &#x22;type&#x22; (or the
* passed in _type_ if present) at the given _offset_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.get" id="apidoc.element.ref.get">
        function <span class="apidocSignatureSpan">ref.</span>get
        <span class="apidocSignatureSpan">(buffer, offset, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function get(buffer, offset, type) {
  if (!offset) {
    offset = 0
  }
  if (type) {
    type = exports.coerceType(type)
  } else {
    type = exports.getType(buffer)
  }
  debug(&#x27;get(): (offset: %d)&#x27;, offset, buffer)
  assert(type.indirection &#x3e; 0, &#x27;&#x22;indirection&#x22; level must be at least 1&#x27;)
  if (type.indirection === 1) {
    // need to check &#x22;type&#x22;
    return type.get(buffer, offset)
  } else {
    // need to create a deref&#x27;d Buffer
    var size = type.indirection === 2 ? type.size : exports.sizeof.pointer
    var reference = exports.readPointer(buffer, offset, size)
    reference.type = exports.derefType(type)
    return reference
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  type = exports.getType(buffer)
}
debug(&#x27;get(): (offset: %d)&#x27;, offset, buffer)
assert(type.indirection &#x3e; 0, &#x27;&#x22;indirection&#x22; level must be at least 1&#x27;)
if (type.indirection === 1) {
  // need to check &#x22;type&#x22;
  return type.<span class="apidocCodeKeywordSpan">get</span>(buffer, offset)
} else {
  // need to create a deref&#x27;d Buffer
  var size = type.indirection === 2 ? type.size : exports.sizeof.pointer
  var reference = exports.readPointer(buffer, offset, size)
  reference.type = exports.derefType(type)
  return reference
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.getType" id="apidoc.element.ref.getType">
        function <span class="apidocSignatureSpan">ref.</span>getType
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getType(buffer) {
  if (!buffer.type) {
    debug(&#x27;WARN: no &#x22;type&#x22; found on buffer, setting default &#x22;type&#x22;&#x27;, buffer)
    buffer.type = {}
    buffer.type.size = buffer.length
    buffer.type.indirection = 1
    buffer.type.get = function get () {
      throw new Error(&#x27;unknown &#x22;type&#x22;; cannot get()&#x27;)
    }
    buffer.type.set = function set () {
      throw new Error(&#x27;unknown &#x22;type&#x22;; cannot set()&#x27;)
    }
  }
  return exports.coerceType(buffer.type)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.get = function get (buffer, offset, type) {
if (!offset) {
  offset = 0
}
if (type) {
  type = exports.coerceType(type)
} else {
  type = exports.<span class="apidocCodeKeywordSpan">getType</span>(buffer)
}
debug(&#x27;get(): (offset: %d)&#x27;, offset, buffer)
assert(type.indirection &#x3e; 0, &#x27;&#x22;indirection&#x22; level must be at least 1&#x27;)
if (type.indirection === 1) {
  // need to check &#x22;type&#x22;
  return type.get(buffer, offset)
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.hexAddress" id="apidoc.element.ref.hexAddress">
        function <span class="apidocSignatureSpan">ref.</span>hexAddress
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hexAddress() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
 * ...
 */

Buffer.prototype.hexAddress = function hexAddress () {
  return exports.<span class="apidocCodeKeywordSpan">hexAddress</span>(this, 0)
}

/**
 * ...
 */

Buffer.prototype.isNull = function isNull () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.isNull" id="apidoc.element.ref.isNull">
        function <span class="apidocSignatureSpan">ref.</span>isNull
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNull() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/

/**
* Accepts a `Buffer` instance and returns _true_ if the buffer represents the
* NULL pointer, _false_ otherwise.
*
* ```
* console.log(ref.<span class="apidocCodeKeywordSpan">isNull</span>(new Buffer(1)));
* false
*
* console.log(ref.isNull(ref.NULL));
* true
* ```
*
* @param {Buffer} buffer The buffer to check for NULL.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.readCString" id="apidoc.element.ref.readCString">
        function <span class="apidocSignatureSpan">ref.</span>readCString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readCString() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* String.
*
* This function can read beyond the `length` of a Buffer.
*
* ```
* var buf = new Buffer(&#x27;hello\0world\0&#x27;);
*
* var str = ref.<span class="apidocCodeKeywordSpan">readCString</span>(buf, 0);
* console.log(str);
* &#x27;hello&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
* @param {Number} offset The offset to begin reading from.
* @return {String} The String that was read from _buffer_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.readInt64" id="apidoc.element.ref.readInt64">
        function <span class="apidocSignatureSpan">ref.</span>readInt64
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var int64temp = new Buffer(exports.sizeof.int64)
var uint64temp = new Buffer(exports.sizeof.uint64)

exports[&#x27;readInt64&#x27; + opposite] = function (buffer, offset) {
  for (var i = 0; i &#x3c; exports.sizeof.int64; i++) {
    int64temp[i] = buffer[offset + exports.sizeof.int64 - i - 1]
  }
  return exports.<span class="apidocCodeKeywordSpan">readInt64</span>(int64temp, 0)
}
exports[&#x27;readUInt64&#x27; + opposite] = function (buffer, offset) {
  for (var i = 0; i &#x3c; exports.sizeof.uint64; i++) {
    uint64temp[i] = buffer[offset + exports.sizeof.uint64 - i - 1]
  }
  return exports.readUInt64(uint64temp, 0)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.readInt64BE" id="apidoc.element.ref.readInt64BE">
        function <span class="apidocSignatureSpan">ref.</span>readInt64BE
        <span class="apidocSignatureSpan">(buffer, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt64BE = function (buffer, offset) {
  for (var i = 0; i &#x3c; exports.sizeof.int64; i++) {
    int64temp[i] = buffer[offset + exports.sizeof.int64 - i - 1]
  }
  return exports.readInt64(int64temp, 0)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;int64&#x27;);
* ref.writeInt64BE(buf, 0, &#x27;9223372036854775807&#x27;);
*
* var val = ref.<span class="apidocCodeKeywordSpan">readInt64BE</span>(buf, 0)
* console.log(val)
* &#x27;9223372036854775807&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
* @param {Number} offset The offset to begin reading from.
* @return {Number|String} The Number or String that was read from _buffer_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.readInt64LE" id="apidoc.element.ref.readInt64LE">
        function <span class="apidocSignatureSpan">ref.</span>readInt64LE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;int64&#x27;);
* ref.writeInt64LE(buf, 0, &#x27;9223372036854775807&#x27;);
*
* var val = ref.<span class="apidocCodeKeywordSpan">readInt64LE</span>(buf, 0)
* console.log(val)
* &#x27;9223372036854775807&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
* @param {Number} offset The offset to begin reading from.
* @return {Number|String} The Number or String that was read from _buffer_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.readObject" id="apidoc.element.ref.readObject">
        function <span class="apidocSignatureSpan">ref.</span>readObject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readObject() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Reads a JavaScript Object that has previously been written to the given
* _buffer_ at the given _offset_.
*
* ```
* var obj = { foo: &#x27;bar&#x27; };
* var buf = ref.alloc(&#x27;Object&#x27;, obj);
*
* var obj2 = ref.<span class="apidocCodeKeywordSpan">readObject</span>(buf, 0);
* console.log(obj === obj2);
* true
* ```
*
* @param {Buffer} buffer The buffer to read an Object from.
* @param {Number} offset The offset to begin reading from.
* @return {Object} The Object that was read from _buffer_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.readPointer" id="apidoc.element.ref.readPointer">
        function <span class="apidocSignatureSpan">ref.</span>readPointer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readPointer() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The _size_ parameter specifies the `length` of the returned Buffer instance,
* which defaults to __0__.
*
* ```
* var buf = new Buffer(&#x27;hello world&#x27;);
* var pointer = ref.alloc(&#x27;pointer&#x27;);
*
* var buf2 = ref.<span class="apidocCodeKeywordSpan">readPointer</span>(pointer, 0, buf.length);
* console.log(buf.toString());
* &#x27;hello world&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
* @param {Number} offset The offset to begin reading from.
* @param {Number} length (optional) The length of the returned Buffer. Defaults to 0.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.readUInt64" id="apidoc.element.ref.readUInt64">
        function <span class="apidocSignatureSpan">ref.</span>readUInt64
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readUInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return exports.readInt64(int64temp, 0)
}
exports[&#x27;readUInt64&#x27; + opposite] = function (buffer, offset) {
  for (var i = 0; i &#x3c; exports.sizeof.uint64; i++) {
    uint64temp[i] = buffer[offset + exports.sizeof.uint64 - i - 1]
  }
  return exports.<span class="apidocCodeKeywordSpan">readUInt64</span>(uint64temp, 0)
}
exports[&#x27;writeInt64&#x27; + opposite] = function (buffer, offset, value) {
  exports.writeInt64(int64temp, 0, value)
  for (var i = 0; i &#x3c; exports.sizeof.int64; i++) {
    buffer[offset + i] = int64temp[exports.sizeof.int64 - i - 1]
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.readUInt64BE" id="apidoc.element.ref.readUInt64BE">
        function <span class="apidocSignatureSpan">ref.</span>readUInt64BE
        <span class="apidocSignatureSpan">(buffer, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt64BE = function (buffer, offset) {
  for (var i = 0; i &#x3c; exports.sizeof.uint64; i++) {
    uint64temp[i] = buffer[offset + exports.sizeof.uint64 - i - 1]
  }
  return exports.readUInt64(uint64temp, 0)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;uint64&#x27;);
* ref.writeUInt64BE(buf, 0, &#x27;18446744073709551615&#x27;);
*
* var val = ref.<span class="apidocCodeKeywordSpan">readUInt64BE</span>(buf, 0)
* console.log(val)
* &#x27;18446744073709551615&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
* @param {Number} offset The offset to begin reading from.
* @return {Number|String} The Number or String that was read from _buffer_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.readUInt64LE" id="apidoc.element.ref.readUInt64LE">
        function <span class="apidocSignatureSpan">ref.</span>readUInt64LE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readUInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;uint64&#x27;);
* ref.writeUInt64LE(buf, 0, &#x27;18446744073709551615&#x27;);
*
* var val = ref.<span class="apidocCodeKeywordSpan">readUInt64LE</span>(buf, 0)
* console.log(val)
* &#x27;18446744073709551615&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
* @param {Number} offset The offset to begin reading from.
* @return {Number|String} The Number or String that was read from _buffer_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.refType" id="apidoc.element.ref.refType">
        function <span class="apidocSignatureSpan">ref.</span>refType
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function refType(type) {
  var _type = exports.coerceType(type)
  var rtn = Object.create(_type)
  rtn.indirection++
  if (_type.name) {
    Object.defineProperty(rtn, &#x27;name&#x27;, {
      value: _type.name + &#x27;*&#x27;,
      configurable: true,
      enumerable: true,
      writable: true
    })
  }
  return rtn
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Returns a new clone of the given &#x22;type&#x22; object, with its
 * `indirection` level incremented by **1**.
 *
 * Say you wanted to create a type representing a `void *`:
 *
 * ```
 * var voidPtrType = ref.<span class="apidocCodeKeywordSpan">refType</span>(ref.types.void);
 * ```
 *
 * @param {Object|String} type The &#x22;type&#x22; object to create a reference type from. Strings get coerced first.
 * @return {Object} The new &#x22;type&#x22; object with its `indirection` incremented by 1.
 */

exports.refType = function refType (type) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.reinterpret" id="apidoc.element.ref.reinterpret">
        function <span class="apidocSignatureSpan">ref.</span>reinterpret
        <span class="apidocSignatureSpan">(buffer, size, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reinterpret(buffer, size, offset) {
  debug(&#x27;reinterpreting buffer to &#x22;%d&#x22; bytes&#x27;, size)
  var rtn = exports._reinterpret(buffer, size, offset || 0)
  exports._attach(rtn, buffer)
  return rtn
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.writePointer = function writePointer (buf, offset, ptr) {
 debug(&#x27;writing pointer to buffer&#x27;, buf, offset, ptr)
 exports._writePointer(buf, offset, ptr)
 exports._attach(buf, ptr)
}

/**
* Same as `ref.<span class="apidocCodeKeywordSpan">reinterpret</span>()`, except that this version does not attach
* _buffer_ to the returned Buffer, which is potentially unsafe if the
* garbage collector runs.
*
* @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.
* @param {Number} size The `length` property of the returned Buffer.
* @param {Number} offset The offset of the Buffer to begin from.
* @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and the requested _size_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.reinterpretUntilZeros" id="apidoc.element.ref.reinterpretUntilZeros">
        function <span class="apidocSignatureSpan">ref.</span>reinterpretUntilZeros
        <span class="apidocSignatureSpan">(buffer, size, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reinterpretUntilZeros(buffer, size, offset) {
  debug(&#x27;reinterpreting buffer to until &#x22;%d&#x22; NULL (0) bytes are found&#x27;, size)
  var rtn = exports._reinterpretUntilZeros(buffer, size, offset || 0)
  exports._attach(rtn, buffer)
  return rtn
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 debug(&#x27;reinterpreting buffer to &#x22;%d&#x22; bytes&#x27;, size)
 var rtn = exports._reinterpret(buffer, size, offset || 0)
 exports._attach(rtn, buffer)
 return rtn
}

/**
* Same as `ref.<span class="apidocCodeKeywordSpan">reinterpretUntilZeros</span>()`, except that this version does not
* attach _buffer_ to the returned Buffer, which is potentially unsafe if the
* garbage collector runs.
*
* @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.
* @param {Number} size The number of sequential, aligned `NULL` bytes that are required to terminate the buffer.
* @param {Number} offset The offset of the Buffer to begin from.
* @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and a variable `length` that is terminated by
 _size_ NUL bytes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.set" id="apidoc.element.ref.set">
        function <span class="apidocSignatureSpan">ref.</span>set
        <span class="apidocSignatureSpan">(buffer, offset, value, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function set(buffer, offset, value, type) {
  if (!offset) {
    offset = 0
  }
  if (type) {
    type = exports.coerceType(type)
  } else {
    type = exports.getType(buffer)
  }
  debug(&#x27;set(): (offset: %d)&#x27;, offset, buffer, value)
  assert(type.indirection &#x3e;= 1, &#x27;&#x22;indirection&#x22; level must be at least 1&#x27;)
  if (type.indirection === 1) {
    type.set(buffer, offset, value)
  } else {
    exports.writePointer(buffer, offset, value)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    type = exports.coerceType(type)
  } else {
    type = exports.getType(buffer)
  }
  debug(&#x27;set(): (offset: %d)&#x27;, offset, buffer, value)
  assert(type.indirection &#x3e;= 1, &#x27;&#x22;indirection&#x22; level must be at least 1&#x27;)
  if (type.indirection === 1) {
    type.<span class="apidocCodeKeywordSpan">set</span>(buffer, offset, value)
  } else {
    exports.writePointer(buffer, offset, value)
  }
}


/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.writeCString" id="apidoc.element.ref.writeCString">
        function <span class="apidocSignatureSpan">ref.</span>writeCString
        <span class="apidocSignatureSpan">(buffer, offset, string, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeCString(buffer, offset, string, encoding) {
  assert(Buffer.isBuffer(buffer), &#x27;expected a Buffer as the first argument&#x27;)
  assert.equal(&#x27;string&#x27;, typeof string, &#x27;expected a &#x22;string&#x22; as the third argument&#x27;)
  if (!offset) {
    offset = 0
  }
  if (!encoding) {
    encoding = &#x27;utf8&#x27;
  }
  var size = buffer.length - offset
  var len = buffer.write(string, offset, size, encoding)
  buffer.writeUInt8(0, offset + len)  // NUL terminate
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.allocCString = function allocCString (string, encoding) {
 if (null == string || (Buffer.isBuffer(string) &#x26;&#x26; exports.isNull(string))) {
   return exports.NULL
 }
 var size = Buffer.byteLength(string, encoding) + 1
 var buffer = new Buffer(size)
 exports.<span class="apidocCodeKeywordSpan">writeCString</span>(buffer, 0, string, encoding)
 buffer.type = charPtrType
 return buffer
}

/**
* Writes the given string as a C String (NULL terminated) to the given buffer
* at the given offset. &#x22;encoding&#x22; is optional and defaults to __&#x27;utf8&#x27;__.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.writeInt64" id="apidoc.element.ref.writeInt64">
        function <span class="apidocSignatureSpan">ref.</span>writeInt64
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , get: function (buffer, offset) {
      // return a bigint instance from the buffer
      return bigint.fromBuffer(buffer)
    }
  , set: function (buffer, offset, value) {
      // &#x27;value&#x27; would be a bigint instance
      var val = value.toString()
      return ref.<span class="apidocCodeKeywordSpan">writeInt64</span>(buffer, offset || 0, val)
    }
}

// now we can create instances of the type from existing buffers.
// &#x22;buf&#x22; is some Buffer instance returned from some external data
// source, which should contain &#x22;bigint&#x22; binary data.
buf.type = BigintType
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.writeInt64BE" id="apidoc.element.ref.writeInt64BE">
        function <span class="apidocSignatureSpan">ref.</span>writeInt64BE
        <span class="apidocSignatureSpan">(buffer, offset, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt64BE = function (buffer, offset, value) {
  exports.writeInt64(int64temp, 0, value)
  for (var i = 0; i &#x3c; exports.sizeof.int64; i++) {
    buffer[offset + i] = int64temp[exports.sizeof.int64 - i - 1]
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* _offset_.
*
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;int64&#x27;);
* ref.<span class="apidocCodeKeywordSpan">writeInt64BE</span>(buf, 0, &#x27;9223372036854775807&#x27;);
*
* var val = ref.readInt64BE(buf, 0)
* console.log(val)
* &#x27;9223372036854775807&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.writeInt64LE" id="apidoc.element.ref.writeInt64LE">
        function <span class="apidocSignatureSpan">ref.</span>writeInt64LE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* _offset_.
*
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;int64&#x27;);
* ref.<span class="apidocCodeKeywordSpan">writeInt64LE</span>(buf, 0, &#x27;9223372036854775807&#x27;);
*
* var val = ref.readInt64LE(buf, 0)
* console.log(val)
* &#x27;9223372036854775807&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.writeObject" id="apidoc.element.ref.writeObject">
        function <span class="apidocSignatureSpan">ref.</span>writeObject
        <span class="apidocSignatureSpan">(buf, offset, obj, persistent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeObject(buf, offset, obj, persistent) {
  debug(&#x27;writing Object to buffer&#x27;, buf, offset, obj, persistent)
  exports._writeObject(buf, offset, obj, persistent)
  exports._attach(buf, obj)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 if (!buf._refs) {
   buf._refs = []
 }
 buf._refs.push(obj)
}

/**
* Same as `ref.<span class="apidocCodeKeywordSpan">writeObject</span>()`, except that this version does not _attach_ the
* Object to the Buffer, which is potentially unsafe if the garbage collector
* runs.
*
* @param {Buffer} buffer A Buffer instance to write _object_ to.
* @param {Number} offset The offset on the Buffer to start writing at.
* @param {Object} object The Object to be written into _buffer_.
* @api private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.writePointer" id="apidoc.element.ref.writePointer">
        function <span class="apidocSignatureSpan">ref.</span>writePointer
        <span class="apidocSignatureSpan">(buf, offset, ptr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writePointer(buf, offset, ptr) {
  debug(&#x27;writing pointer to buffer&#x27;, buf, offset, ptr)
  exports._writePointer(buf, offset, ptr)
  exports._attach(buf, ptr)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   type = exports.getType(buffer)
 }
 debug(&#x27;set(): (offset: %d)&#x27;, offset, buffer, value)
 assert(type.indirection &#x3e;= 1, &#x27;&#x22;indirection&#x22; level must be at least 1&#x27;)
 if (type.indirection === 1) {
   type.set(buffer, offset, value)
 } else {
   exports.<span class="apidocCodeKeywordSpan">writePointer</span>(buffer, offset, value)
 }
}


/**
* Returns a new Buffer instance big enough to hold `type`,
* with the given `value` written to it.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.writeUInt64" id="apidoc.element.ref.writeUInt64">
        function <span class="apidocSignatureSpan">ref.</span>writeUInt64
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeUInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports[&#x27;writeInt64&#x27; + opposite] = function (buffer, offset, value) {
 exports.writeInt64(int64temp, 0, value)
 for (var i = 0; i &#x3c; exports.sizeof.int64; i++) {
   buffer[offset + i] = int64temp[exports.sizeof.int64 - i - 1]
 }
}
exports[&#x27;writeUInt64&#x27; + opposite] = function (buffer, offset, value) {
 exports.<span class="apidocCodeKeywordSpan">writeUInt64</span>(uint64temp, 0, value)
 for (var i = 0; i &#x3c; exports.sizeof.uint64; i++) {
   buffer[offset + i] = uint64temp[exports.sizeof.uint64 - i - 1]
 }
}

/**
* `ref()` accepts a Buffer instance and returns a new Buffer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.writeUInt64BE" id="apidoc.element.ref.writeUInt64BE">
        function <span class="apidocSignatureSpan">ref.</span>writeUInt64BE
        <span class="apidocSignatureSpan">(buffer, offset, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt64BE = function (buffer, offset, value) {
  exports.writeUInt64(uint64temp, 0, value)
  for (var i = 0; i &#x3c; exports.sizeof.uint64; i++) {
    buffer[offset + i] = uint64temp[exports.sizeof.uint64 - i - 1]
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* _offset_.
*
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;uint64&#x27;);
* ref.<span class="apidocCodeKeywordSpan">writeUInt64BE</span>(buf, 0, &#x27;18446744073709551615&#x27;);
*
* var val = ref.readUInt64BE(buf, 0)
* console.log(val)
* &#x27;18446744073709551615&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.writeUInt64LE" id="apidoc.element.ref.writeUInt64LE">
        function <span class="apidocSignatureSpan">ref.</span>writeUInt64LE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeUInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* _offset_.
*
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;uint64&#x27;);
* ref.<span class="apidocCodeKeywordSpan">writeUInt64LE</span>(buf, 0, &#x27;18446744073709551615&#x27;);
*
* var val = ref.readUInt64LE(buf, 0)
* console.log(val)
* &#x27;18446744073709551615&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
...</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ref.ref" id="apidoc.module.ref.ref">module ref.ref</a></h1>


    <h2>
        <a href="#apidoc.element.ref.ref.ref" id="apidoc.element.ref.ref.ref">
        function <span class="apidocSignatureSpan">ref.</span>ref
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ref(buffer) {
  debug(&#x27;creating a reference to buffer&#x27;, buffer)
  var type = exports.refType(exports.getType(buffer))
  return exports.alloc(type, buffer)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// now we can dereference to get the &#x22;meaningful&#x22; value
console.log(buf.deref())  // ← 12345


// you can also get references to the original buffer if you need it.
// this buffer could be thought of as an &#x22;int **&#x22;
var one = buf.<span class="apidocCodeKeywordSpan">ref</span>()

// and you can dereference all the way back down to an int
console.log(one.deref().deref())  // ← 12345
```

See the [full API Docs][docs] for more examples.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref._attach" id="apidoc.element.ref.ref._attach">
        function <span class="apidocSignatureSpan">ref.ref.</span>_attach
        <span class="apidocSignatureSpan">(buf, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _attach(buf, obj) {
  if (!buf._refs) {
    buf._refs = []
  }
  buf._refs.push(obj)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Number} offset The offset on the Buffer to start writing at.
* @param {Object} object The Object to be written into _buffer_.
*/

exports.writeObject = function writeObject (buf, offset, obj, persistent) {
 debug(&#x27;writing Object to buffer&#x27;, buf, offset, obj, persistent)
 exports._writeObject(buf, offset, obj, persistent)
 exports.<span class="apidocCodeKeywordSpan">_attach</span>(buf, obj)
}

/**
* Same as `ref.writePointer()`, except that this version does not attach
* _pointer_ to _buffer_, which is potentially unsafe if the garbage collector
* runs.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref._reinterpret" id="apidoc.element.ref.ref._reinterpret">
        function <span class="apidocSignatureSpan">ref.ref.</span>_reinterpret
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reinterpret() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Number} size The `length` property of the returned Buffer.
* @param {Number} offset The offset of the Buffer to begin from.
* @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and the requested _size_.
*/

exports.reinterpret = function reinterpret (buffer, size, offset) {
 debug(&#x27;reinterpreting buffer to &#x22;%d&#x22; bytes&#x27;, size)
 var rtn = exports.<span class="apidocCodeKeywordSpan">_reinterpret</span>(buffer, size, offset || 0)
 exports._attach(rtn, buffer)
 return rtn
}

/**
* Same as `ref.reinterpretUntilZeros()`, except that this version does not
* attach _buffer_ to the returned Buffer, which is potentially unsafe if the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref._reinterpretUntilZeros" id="apidoc.element.ref.ref._reinterpretUntilZeros">
        function <span class="apidocSignatureSpan">ref.ref.</span>_reinterpretUntilZeros
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reinterpretUntilZeros() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Number} size The number of sequential, aligned `NULL` bytes are required to terminate the buffer.
 * @param {Number} offset The offset of the Buffer to begin from.
 * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and a variable `length` that is terminated by
 _size_ NUL bytes.
 */

exports.reinterpretUntilZeros = function reinterpretUntilZeros (buffer, size, offset) {
  debug(&#x27;reinterpreting buffer to until &#x22;%d&#x22; NULL (0) bytes are found&#x27;, size)
  var rtn = exports.<span class="apidocCodeKeywordSpan">_reinterpretUntilZeros</span>(buffer, size, offset || 0)
  exports._attach(rtn, buffer)
  return rtn
}


// the built-in &#x22;types&#x22;
var types = exports.types = {}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref._writeObject" id="apidoc.element.ref.ref._writeObject">
        function <span class="apidocSignatureSpan">ref.ref.</span>_writeObject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeObject() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Buffer} buffer A Buffer instance to write _object_ to.
* @param {Number} offset The offset on the Buffer to start writing at.
* @param {Object} object The Object to be written into _buffer_.
*/

exports.writeObject = function writeObject (buf, offset, obj, persistent) {
 debug(&#x27;writing Object to buffer&#x27;, buf, offset, obj, persistent)
 exports.<span class="apidocCodeKeywordSpan">_writeObject</span>(buf, offset, obj, persistent)
 exports._attach(buf, obj)
}

/**
* Same as `ref.writePointer()`, except that this version does not attach
* _pointer_ to _buffer_, which is potentially unsafe if the garbage collector
* runs.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref._writePointer" id="apidoc.element.ref.ref._writePointer">
        function <span class="apidocSignatureSpan">ref.ref.</span>_writePointer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writePointer() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Buffer} buffer A Buffer instance to write _pointer to.
* @param {Number} offset The offset on the Buffer to start writing at.
* @param {Buffer} pointer The Buffer instance whose memory address will be written to _buffer_.
*/

exports.writePointer = function writePointer (buf, offset, ptr) {
 debug(&#x27;writing pointer to buffer&#x27;, buf, offset, ptr)
 exports.<span class="apidocCodeKeywordSpan">_writePointer</span>(buf, offset, ptr)
 exports._attach(buf, ptr)
}

/**
* Same as `ref.reinterpret()`, except that this version does not attach
* _buffer_ to the returned Buffer, which is potentially unsafe if the
* garbage collector runs.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.address" id="apidoc.element.ref.ref.address">
        function <span class="apidocSignatureSpan">ref.ref.</span>address
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function address() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// so we can all agree that a buffer with the int value written
// to it could be represented as an &#x22;int *&#x22;
var buf = new Buffer(4)
buf.writeInt32LE(12345, 0)

// first, what is the memory address of the buffer?
console.log(buf.<span class="apidocCodeKeywordSpan">address</span>())  // ← 140362165284824

// using `ref`, you can set the &#x22;type&#x22;, and gain magic abilities!
buf.type = ref.types.int

// now we can dereference to get the &#x22;meaningful&#x22; value
console.log(buf.deref())  // ← 12345
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.alloc" id="apidoc.element.ref.ref.alloc">
        function <span class="apidocSignatureSpan">ref.ref.</span>alloc
        <span class="apidocSignatureSpan">(_type, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function alloc(_type, value) {
  var type = exports.coerceType(_type)
  debug(&#x27;allocating Buffer for type with &#x22;size&#x22;&#x27;, type.size)
  var size
  if (type.indirection === 1) {
    size = type.size
  } else {
    size = exports.sizeof.pointer
  }
  var buffer = new Buffer(size)
  buffer.type = type
  if (arguments.length &#x3e;= 2) {
    debug(&#x27;setting value on allocated buffer&#x27;, value)
    exports.set(buffer, 0, value, type)
  }
  return buffer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Reads a JavaScript Object that has previously been written to the given
* _buffer_ at the given _offset_.
*
* ```
* var obj = { foo: &#x27;bar&#x27; };
* var buf = ref.<span class="apidocCodeKeywordSpan">alloc</span>(&#x27;Object&#x27;, obj);
*
* var obj2 = ref.readObject(buf, 0);
* console.log(obj === obj2);
* true
* ```
*
* @param {Buffer} buffer The buffer to read an Object from.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.allocCString" id="apidoc.element.ref.ref.allocCString">
        function <span class="apidocSignatureSpan">ref.ref.</span>allocCString
        <span class="apidocSignatureSpan">(string, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function allocCString(string, encoding) {
  if (null == string || (Buffer.isBuffer(string) &#x26;&#x26; exports.isNull(string))) {
    return exports.NULL
  }
  var size = Buffer.byteLength(string, encoding) + 1
  var buffer = new Buffer(size)
  exports.writeCString(buffer, 0, string, encoding)
  buffer.type = charPtrType
  return buffer
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Returns a new `Buffer` instance with the given String written to it with the
* given encoding (defaults to __&#x27;utf8&#x27;__). The buffer is 1 byte longer than the
* string itself, and is NUL terminated.
*
* ```
* var buf = ref.<span class="apidocCodeKeywordSpan">allocCString</span>(&#x27;hello world&#x27;);
*
* console.log(buf.toString());
* &#x27;hello world\u0000&#x27;
* ```
*
* @param {String} string The JavaScript string to be converted to a C string.
* @param {String} encoding (optional) The encoding to use for the C string. Defaults to __&#x27;utf8&#x27;__.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.coerceType" id="apidoc.element.ref.ref.coerceType">
        function <span class="apidocSignatureSpan">ref.ref.</span>coerceType
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function coerceType(type) {
  var rtn = type
  if (typeof rtn === &#x27;string&#x27;) {
    rtn = exports.types[type]
    if (rtn) return rtn

    // strip whitespace
    rtn = type.replace(/\s+/g, &#x27;&#x27;).toLowerCase()
    if (rtn === &#x27;pointer&#x27;) {
      // legacy &#x22;pointer&#x22; being used :(
      rtn = exports.refType(exports.types.void) // void *
    } else if (rtn === &#x27;string&#x27;) {
      rtn = exports.types.CString // special char * type
    } else {
      var refCount = 0
      rtn = rtn.replace(/\*/g, function () {
        refCount++
        return &#x27;&#x27;
      })
      // allow string names to be passed in
      rtn = exports.types[rtn]
      if (refCount &#x3e; 0) {
        if (!(rtn &#x26;&#x26; &#x27;size&#x27; in rtn &#x26;&#x26; &#x27;indirection&#x27; in rtn)) {
          throw new TypeError(&#x27;could not determine a proper &#x22;type&#x22; from: &#x27; + JSON.stringify(type))
        }
        for (var i = 0; i &#x3c; refCount; i++) {
          rtn = exports.refType(rtn)
        }
      }
    }
  }
  if (!(rtn &#x26;&#x26; &#x27;size&#x27; in rtn &#x26;&#x26; &#x27;indirection&#x27; in rtn)) {
    throw new TypeError(&#x27;could not determine a proper &#x22;type&#x22; from: &#x27; + JSON.stringify(type))
  }
  return rtn
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * ```
 *
 * @param {Object|String} type The &#x22;type&#x22; object to create a reference type from. Strings get coerced first.
 * @return {Object} The new &#x22;type&#x22; object with its `indirection` incremented by 1.
 */

exports.refType = function refType (type) {
var _type = exports.<span class="apidocCodeKeywordSpan">coerceType</span>(type)
var rtn = Object.create(_type)
rtn.indirection++
if (_type.name) {
  Object.defineProperty(rtn, &#x27;name&#x27;, {
    value: _type.name + &#x27;*&#x27;,
    configurable: true,
    enumerable: true,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.deref" id="apidoc.element.ref.ref.deref">
        function <span class="apidocSignatureSpan">ref.ref.</span>deref
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deref(buffer) {
  debug(&#x27;dereferencing buffer&#x27;, buffer)
  return exports.get(buffer)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// first, what is the memory address of the buffer?
console.log(buf.address())  // ← 140362165284824

// using `ref`, you can set the &#x22;type&#x22;, and gain magic abilities!
buf.type = ref.types.int

// now we can dereference to get the &#x22;meaningful&#x22; value
console.log(buf.<span class="apidocCodeKeywordSpan">deref</span>())  // ← 12345


// you can also get references to the original buffer if you need it.
// this buffer could be thought of as an &#x22;int **&#x22;
var one = buf.ref()

// and you can dereference all the way back down to an int
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.derefType" id="apidoc.element.ref.ref.derefType">
        function <span class="apidocSignatureSpan">ref.ref.</span>derefType
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function derefType(type) {
  var _type = exports.coerceType(type)
  if (_type.indirection === 1) {
    throw new Error(&#x27;Cannot create deref\&#x27;d type for type with indirection 1&#x27;)
  }
  var rtn = Object.getPrototypeOf(_type)
  if (rtn.indirection !== _type.indirection - 1) {
    // slow case
    rtn = Object.create(_type)
    rtn.indirection--
  }
  return rtn
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 if (type.indirection === 1) {
   // need to check &#x22;type&#x22;
   return type.get(buffer, offset)
 } else {
   // need to create a deref&#x27;d Buffer
   var size = type.indirection === 2 ? type.size : exports.sizeof.pointer
   var reference = exports.readPointer(buffer, offset, size)
   reference.type = exports.<span class="apidocCodeKeywordSpan">derefType</span>(type)
   return reference
 }
}

/**
* Calls the `set()` function of the Buffer&#x27;s current &#x22;type&#x22; (or the
* passed in _type_ if present) at the given _offset_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.get" id="apidoc.element.ref.ref.get">
        function <span class="apidocSignatureSpan">ref.ref.</span>get
        <span class="apidocSignatureSpan">(buffer, offset, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function get(buffer, offset, type) {
  if (!offset) {
    offset = 0
  }
  if (type) {
    type = exports.coerceType(type)
  } else {
    type = exports.getType(buffer)
  }
  debug(&#x27;get(): (offset: %d)&#x27;, offset, buffer)
  assert(type.indirection &#x3e; 0, &#x27;&#x22;indirection&#x22; level must be at least 1&#x27;)
  if (type.indirection === 1) {
    // need to check &#x22;type&#x22;
    return type.get(buffer, offset)
  } else {
    // need to create a deref&#x27;d Buffer
    var size = type.indirection === 2 ? type.size : exports.sizeof.pointer
    var reference = exports.readPointer(buffer, offset, size)
    reference.type = exports.derefType(type)
    return reference
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  type = exports.getType(buffer)
}
debug(&#x27;get(): (offset: %d)&#x27;, offset, buffer)
assert(type.indirection &#x3e; 0, &#x27;&#x22;indirection&#x22; level must be at least 1&#x27;)
if (type.indirection === 1) {
  // need to check &#x22;type&#x22;
  return type.<span class="apidocCodeKeywordSpan">get</span>(buffer, offset)
} else {
  // need to create a deref&#x27;d Buffer
  var size = type.indirection === 2 ? type.size : exports.sizeof.pointer
  var reference = exports.readPointer(buffer, offset, size)
  reference.type = exports.derefType(type)
  return reference
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.getType" id="apidoc.element.ref.ref.getType">
        function <span class="apidocSignatureSpan">ref.ref.</span>getType
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getType(buffer) {
  if (!buffer.type) {
    debug(&#x27;WARN: no &#x22;type&#x22; found on buffer, setting default &#x22;type&#x22;&#x27;, buffer)
    buffer.type = {}
    buffer.type.size = buffer.length
    buffer.type.indirection = 1
    buffer.type.get = function get () {
      throw new Error(&#x27;unknown &#x22;type&#x22;; cannot get()&#x27;)
    }
    buffer.type.set = function set () {
      throw new Error(&#x27;unknown &#x22;type&#x22;; cannot set()&#x27;)
    }
  }
  return exports.coerceType(buffer.type)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.get = function get (buffer, offset, type) {
if (!offset) {
  offset = 0
}
if (type) {
  type = exports.coerceType(type)
} else {
  type = exports.<span class="apidocCodeKeywordSpan">getType</span>(buffer)
}
debug(&#x27;get(): (offset: %d)&#x27;, offset, buffer)
assert(type.indirection &#x3e; 0, &#x27;&#x22;indirection&#x22; level must be at least 1&#x27;)
if (type.indirection === 1) {
  // need to check &#x22;type&#x22;
  return type.get(buffer, offset)
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.hexAddress" id="apidoc.element.ref.ref.hexAddress">
        function <span class="apidocSignatureSpan">ref.ref.</span>hexAddress
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hexAddress() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
 * ...
 */

Buffer.prototype.hexAddress = function hexAddress () {
  return exports.<span class="apidocCodeKeywordSpan">hexAddress</span>(this, 0)
}

/**
 * ...
 */

Buffer.prototype.isNull = function isNull () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.isNull" id="apidoc.element.ref.ref.isNull">
        function <span class="apidocSignatureSpan">ref.ref.</span>isNull
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNull() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/

/**
* Accepts a `Buffer` instance and returns _true_ if the buffer represents the
* NULL pointer, _false_ otherwise.
*
* ```
* console.log(ref.<span class="apidocCodeKeywordSpan">isNull</span>(new Buffer(1)));
* false
*
* console.log(ref.isNull(ref.NULL));
* true
* ```
*
* @param {Buffer} buffer The buffer to check for NULL.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.readCString" id="apidoc.element.ref.ref.readCString">
        function <span class="apidocSignatureSpan">ref.ref.</span>readCString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readCString() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* String.
*
* This function can read beyond the `length` of a Buffer.
*
* ```
* var buf = new Buffer(&#x27;hello\0world\0&#x27;);
*
* var str = ref.<span class="apidocCodeKeywordSpan">readCString</span>(buf, 0);
* console.log(str);
* &#x27;hello&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
* @param {Number} offset The offset to begin reading from.
* @return {String} The String that was read from _buffer_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.readInt64" id="apidoc.element.ref.ref.readInt64">
        function <span class="apidocSignatureSpan">ref.ref.</span>readInt64
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var int64temp = new Buffer(exports.sizeof.int64)
var uint64temp = new Buffer(exports.sizeof.uint64)

exports[&#x27;readInt64&#x27; + opposite] = function (buffer, offset) {
  for (var i = 0; i &#x3c; exports.sizeof.int64; i++) {
    int64temp[i] = buffer[offset + exports.sizeof.int64 - i - 1]
  }
  return exports.<span class="apidocCodeKeywordSpan">readInt64</span>(int64temp, 0)
}
exports[&#x27;readUInt64&#x27; + opposite] = function (buffer, offset) {
  for (var i = 0; i &#x3c; exports.sizeof.uint64; i++) {
    uint64temp[i] = buffer[offset + exports.sizeof.uint64 - i - 1]
  }
  return exports.readUInt64(uint64temp, 0)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.readInt64BE" id="apidoc.element.ref.ref.readInt64BE">
        function <span class="apidocSignatureSpan">ref.ref.</span>readInt64BE
        <span class="apidocSignatureSpan">(buffer, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt64BE = function (buffer, offset) {
  for (var i = 0; i &#x3c; exports.sizeof.int64; i++) {
    int64temp[i] = buffer[offset + exports.sizeof.int64 - i - 1]
  }
  return exports.readInt64(int64temp, 0)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;int64&#x27;);
* ref.writeInt64BE(buf, 0, &#x27;9223372036854775807&#x27;);
*
* var val = ref.<span class="apidocCodeKeywordSpan">readInt64BE</span>(buf, 0)
* console.log(val)
* &#x27;9223372036854775807&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
* @param {Number} offset The offset to begin reading from.
* @return {Number|String} The Number or String that was read from _buffer_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.readInt64LE" id="apidoc.element.ref.ref.readInt64LE">
        function <span class="apidocSignatureSpan">ref.ref.</span>readInt64LE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;int64&#x27;);
* ref.writeInt64LE(buf, 0, &#x27;9223372036854775807&#x27;);
*
* var val = ref.<span class="apidocCodeKeywordSpan">readInt64LE</span>(buf, 0)
* console.log(val)
* &#x27;9223372036854775807&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
* @param {Number} offset The offset to begin reading from.
* @return {Number|String} The Number or String that was read from _buffer_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.readObject" id="apidoc.element.ref.ref.readObject">
        function <span class="apidocSignatureSpan">ref.ref.</span>readObject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readObject() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Reads a JavaScript Object that has previously been written to the given
* _buffer_ at the given _offset_.
*
* ```
* var obj = { foo: &#x27;bar&#x27; };
* var buf = ref.alloc(&#x27;Object&#x27;, obj);
*
* var obj2 = ref.<span class="apidocCodeKeywordSpan">readObject</span>(buf, 0);
* console.log(obj === obj2);
* true
* ```
*
* @param {Buffer} buffer The buffer to read an Object from.
* @param {Number} offset The offset to begin reading from.
* @return {Object} The Object that was read from _buffer_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.readPointer" id="apidoc.element.ref.ref.readPointer">
        function <span class="apidocSignatureSpan">ref.ref.</span>readPointer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readPointer() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The _size_ parameter specifies the `length` of the returned Buffer instance,
* which defaults to __0__.
*
* ```
* var buf = new Buffer(&#x27;hello world&#x27;);
* var pointer = ref.alloc(&#x27;pointer&#x27;);
*
* var buf2 = ref.<span class="apidocCodeKeywordSpan">readPointer</span>(pointer, 0, buf.length);
* console.log(buf.toString());
* &#x27;hello world&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
* @param {Number} offset The offset to begin reading from.
* @param {Number} length (optional) The length of the returned Buffer. Defaults to 0.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.readUInt64" id="apidoc.element.ref.ref.readUInt64">
        function <span class="apidocSignatureSpan">ref.ref.</span>readUInt64
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readUInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return exports.readInt64(int64temp, 0)
}
exports[&#x27;readUInt64&#x27; + opposite] = function (buffer, offset) {
  for (var i = 0; i &#x3c; exports.sizeof.uint64; i++) {
    uint64temp[i] = buffer[offset + exports.sizeof.uint64 - i - 1]
  }
  return exports.<span class="apidocCodeKeywordSpan">readUInt64</span>(uint64temp, 0)
}
exports[&#x27;writeInt64&#x27; + opposite] = function (buffer, offset, value) {
  exports.writeInt64(int64temp, 0, value)
  for (var i = 0; i &#x3c; exports.sizeof.int64; i++) {
    buffer[offset + i] = int64temp[exports.sizeof.int64 - i - 1]
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.readUInt64BE" id="apidoc.element.ref.ref.readUInt64BE">
        function <span class="apidocSignatureSpan">ref.ref.</span>readUInt64BE
        <span class="apidocSignatureSpan">(buffer, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt64BE = function (buffer, offset) {
  for (var i = 0; i &#x3c; exports.sizeof.uint64; i++) {
    uint64temp[i] = buffer[offset + exports.sizeof.uint64 - i - 1]
  }
  return exports.readUInt64(uint64temp, 0)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;uint64&#x27;);
* ref.writeUInt64BE(buf, 0, &#x27;18446744073709551615&#x27;);
*
* var val = ref.<span class="apidocCodeKeywordSpan">readUInt64BE</span>(buf, 0)
* console.log(val)
* &#x27;18446744073709551615&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
* @param {Number} offset The offset to begin reading from.
* @return {Number|String} The Number or String that was read from _buffer_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.readUInt64LE" id="apidoc.element.ref.ref.readUInt64LE">
        function <span class="apidocSignatureSpan">ref.ref.</span>readUInt64LE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readUInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;uint64&#x27;);
* ref.writeUInt64LE(buf, 0, &#x27;18446744073709551615&#x27;);
*
* var val = ref.<span class="apidocCodeKeywordSpan">readUInt64LE</span>(buf, 0)
* console.log(val)
* &#x27;18446744073709551615&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
* @param {Number} offset The offset to begin reading from.
* @return {Number|String} The Number or String that was read from _buffer_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.refType" id="apidoc.element.ref.ref.refType">
        function <span class="apidocSignatureSpan">ref.ref.</span>refType
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function refType(type) {
  var _type = exports.coerceType(type)
  var rtn = Object.create(_type)
  rtn.indirection++
  if (_type.name) {
    Object.defineProperty(rtn, &#x27;name&#x27;, {
      value: _type.name + &#x27;*&#x27;,
      configurable: true,
      enumerable: true,
      writable: true
    })
  }
  return rtn
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Returns a new clone of the given &#x22;type&#x22; object, with its
 * `indirection` level incremented by **1**.
 *
 * Say you wanted to create a type representing a `void *`:
 *
 * ```
 * var voidPtrType = ref.<span class="apidocCodeKeywordSpan">refType</span>(ref.types.void);
 * ```
 *
 * @param {Object|String} type The &#x22;type&#x22; object to create a reference type from. Strings get coerced first.
 * @return {Object} The new &#x22;type&#x22; object with its `indirection` incremented by 1.
 */

exports.refType = function refType (type) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.reinterpret" id="apidoc.element.ref.ref.reinterpret">
        function <span class="apidocSignatureSpan">ref.ref.</span>reinterpret
        <span class="apidocSignatureSpan">(buffer, size, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reinterpret(buffer, size, offset) {
  debug(&#x27;reinterpreting buffer to &#x22;%d&#x22; bytes&#x27;, size)
  var rtn = exports._reinterpret(buffer, size, offset || 0)
  exports._attach(rtn, buffer)
  return rtn
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.writePointer = function writePointer (buf, offset, ptr) {
 debug(&#x27;writing pointer to buffer&#x27;, buf, offset, ptr)
 exports._writePointer(buf, offset, ptr)
 exports._attach(buf, ptr)
}

/**
* Same as `ref.<span class="apidocCodeKeywordSpan">reinterpret</span>()`, except that this version does not attach
* _buffer_ to the returned Buffer, which is potentially unsafe if the
* garbage collector runs.
*
* @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.
* @param {Number} size The `length` property of the returned Buffer.
* @param {Number} offset The offset of the Buffer to begin from.
* @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and the requested _size_.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.reinterpretUntilZeros" id="apidoc.element.ref.ref.reinterpretUntilZeros">
        function <span class="apidocSignatureSpan">ref.ref.</span>reinterpretUntilZeros
        <span class="apidocSignatureSpan">(buffer, size, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reinterpretUntilZeros(buffer, size, offset) {
  debug(&#x27;reinterpreting buffer to until &#x22;%d&#x22; NULL (0) bytes are found&#x27;, size)
  var rtn = exports._reinterpretUntilZeros(buffer, size, offset || 0)
  exports._attach(rtn, buffer)
  return rtn
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 debug(&#x27;reinterpreting buffer to &#x22;%d&#x22; bytes&#x27;, size)
 var rtn = exports._reinterpret(buffer, size, offset || 0)
 exports._attach(rtn, buffer)
 return rtn
}

/**
* Same as `ref.<span class="apidocCodeKeywordSpan">reinterpretUntilZeros</span>()`, except that this version does not
* attach _buffer_ to the returned Buffer, which is potentially unsafe if the
* garbage collector runs.
*
* @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.
* @param {Number} size The number of sequential, aligned `NULL` bytes that are required to terminate the buffer.
* @param {Number} offset The offset of the Buffer to begin from.
* @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and a variable `length` that is terminated by
 _size_ NUL bytes.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.set" id="apidoc.element.ref.ref.set">
        function <span class="apidocSignatureSpan">ref.ref.</span>set
        <span class="apidocSignatureSpan">(buffer, offset, value, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function set(buffer, offset, value, type) {
  if (!offset) {
    offset = 0
  }
  if (type) {
    type = exports.coerceType(type)
  } else {
    type = exports.getType(buffer)
  }
  debug(&#x27;set(): (offset: %d)&#x27;, offset, buffer, value)
  assert(type.indirection &#x3e;= 1, &#x27;&#x22;indirection&#x22; level must be at least 1&#x27;)
  if (type.indirection === 1) {
    type.set(buffer, offset, value)
  } else {
    exports.writePointer(buffer, offset, value)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    type = exports.coerceType(type)
  } else {
    type = exports.getType(buffer)
  }
  debug(&#x27;set(): (offset: %d)&#x27;, offset, buffer, value)
  assert(type.indirection &#x3e;= 1, &#x27;&#x22;indirection&#x22; level must be at least 1&#x27;)
  if (type.indirection === 1) {
    type.<span class="apidocCodeKeywordSpan">set</span>(buffer, offset, value)
  } else {
    exports.writePointer(buffer, offset, value)
  }
}


/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.writeCString" id="apidoc.element.ref.ref.writeCString">
        function <span class="apidocSignatureSpan">ref.ref.</span>writeCString
        <span class="apidocSignatureSpan">(buffer, offset, string, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeCString(buffer, offset, string, encoding) {
  assert(Buffer.isBuffer(buffer), &#x27;expected a Buffer as the first argument&#x27;)
  assert.equal(&#x27;string&#x27;, typeof string, &#x27;expected a &#x22;string&#x22; as the third argument&#x27;)
  if (!offset) {
    offset = 0
  }
  if (!encoding) {
    encoding = &#x27;utf8&#x27;
  }
  var size = buffer.length - offset
  var len = buffer.write(string, offset, size, encoding)
  buffer.writeUInt8(0, offset + len)  // NUL terminate
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.allocCString = function allocCString (string, encoding) {
 if (null == string || (Buffer.isBuffer(string) &#x26;&#x26; exports.isNull(string))) {
   return exports.NULL
 }
 var size = Buffer.byteLength(string, encoding) + 1
 var buffer = new Buffer(size)
 exports.<span class="apidocCodeKeywordSpan">writeCString</span>(buffer, 0, string, encoding)
 buffer.type = charPtrType
 return buffer
}

/**
* Writes the given string as a C String (NULL terminated) to the given buffer
* at the given offset. &#x22;encoding&#x22; is optional and defaults to __&#x27;utf8&#x27;__.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.writeInt64" id="apidoc.element.ref.ref.writeInt64">
        function <span class="apidocSignatureSpan">ref.ref.</span>writeInt64
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , get: function (buffer, offset) {
      // return a bigint instance from the buffer
      return bigint.fromBuffer(buffer)
    }
  , set: function (buffer, offset, value) {
      // &#x27;value&#x27; would be a bigint instance
      var val = value.toString()
      return ref.<span class="apidocCodeKeywordSpan">writeInt64</span>(buffer, offset || 0, val)
    }
}

// now we can create instances of the type from existing buffers.
// &#x22;buf&#x22; is some Buffer instance returned from some external data
// source, which should contain &#x22;bigint&#x22; binary data.
buf.type = BigintType
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.writeInt64BE" id="apidoc.element.ref.ref.writeInt64BE">
        function <span class="apidocSignatureSpan">ref.ref.</span>writeInt64BE
        <span class="apidocSignatureSpan">(buffer, offset, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt64BE = function (buffer, offset, value) {
  exports.writeInt64(int64temp, 0, value)
  for (var i = 0; i &#x3c; exports.sizeof.int64; i++) {
    buffer[offset + i] = int64temp[exports.sizeof.int64 - i - 1]
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* _offset_.
*
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;int64&#x27;);
* ref.<span class="apidocCodeKeywordSpan">writeInt64BE</span>(buf, 0, &#x27;9223372036854775807&#x27;);
*
* var val = ref.readInt64BE(buf, 0)
* console.log(val)
* &#x27;9223372036854775807&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.writeInt64LE" id="apidoc.element.ref.ref.writeInt64LE">
        function <span class="apidocSignatureSpan">ref.ref.</span>writeInt64LE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* _offset_.
*
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;int64&#x27;);
* ref.<span class="apidocCodeKeywordSpan">writeInt64LE</span>(buf, 0, &#x27;9223372036854775807&#x27;);
*
* var val = ref.readInt64LE(buf, 0)
* console.log(val)
* &#x27;9223372036854775807&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.writeObject" id="apidoc.element.ref.ref.writeObject">
        function <span class="apidocSignatureSpan">ref.ref.</span>writeObject
        <span class="apidocSignatureSpan">(buf, offset, obj, persistent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeObject(buf, offset, obj, persistent) {
  debug(&#x27;writing Object to buffer&#x27;, buf, offset, obj, persistent)
  exports._writeObject(buf, offset, obj, persistent)
  exports._attach(buf, obj)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 if (!buf._refs) {
   buf._refs = []
 }
 buf._refs.push(obj)
}

/**
* Same as `ref.<span class="apidocCodeKeywordSpan">writeObject</span>()`, except that this version does not _attach_ the
* Object to the Buffer, which is potentially unsafe if the garbage collector
* runs.
*
* @param {Buffer} buffer A Buffer instance to write _object_ to.
* @param {Number} offset The offset on the Buffer to start writing at.
* @param {Object} object The Object to be written into _buffer_.
* @api private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.writePointer" id="apidoc.element.ref.ref.writePointer">
        function <span class="apidocSignatureSpan">ref.ref.</span>writePointer
        <span class="apidocSignatureSpan">(buf, offset, ptr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writePointer(buf, offset, ptr) {
  debug(&#x27;writing pointer to buffer&#x27;, buf, offset, ptr)
  exports._writePointer(buf, offset, ptr)
  exports._attach(buf, ptr)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   type = exports.getType(buffer)
 }
 debug(&#x27;set(): (offset: %d)&#x27;, offset, buffer, value)
 assert(type.indirection &#x3e;= 1, &#x27;&#x22;indirection&#x22; level must be at least 1&#x27;)
 if (type.indirection === 1) {
   type.set(buffer, offset, value)
 } else {
   exports.<span class="apidocCodeKeywordSpan">writePointer</span>(buffer, offset, value)
 }
}


/**
* Returns a new Buffer instance big enough to hold `type`,
* with the given `value` written to it.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.writeUInt64" id="apidoc.element.ref.ref.writeUInt64">
        function <span class="apidocSignatureSpan">ref.ref.</span>writeUInt64
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeUInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports[&#x27;writeInt64&#x27; + opposite] = function (buffer, offset, value) {
 exports.writeInt64(int64temp, 0, value)
 for (var i = 0; i &#x3c; exports.sizeof.int64; i++) {
   buffer[offset + i] = int64temp[exports.sizeof.int64 - i - 1]
 }
}
exports[&#x27;writeUInt64&#x27; + opposite] = function (buffer, offset, value) {
 exports.<span class="apidocCodeKeywordSpan">writeUInt64</span>(uint64temp, 0, value)
 for (var i = 0; i &#x3c; exports.sizeof.uint64; i++) {
   buffer[offset + i] = uint64temp[exports.sizeof.uint64 - i - 1]
 }
}

/**
* `ref()` accepts a Buffer instance and returns a new Buffer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.writeUInt64BE" id="apidoc.element.ref.ref.writeUInt64BE">
        function <span class="apidocSignatureSpan">ref.ref.</span>writeUInt64BE
        <span class="apidocSignatureSpan">(buffer, offset, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt64BE = function (buffer, offset, value) {
  exports.writeUInt64(uint64temp, 0, value)
  for (var i = 0; i &#x3c; exports.sizeof.uint64; i++) {
    buffer[offset + i] = uint64temp[exports.sizeof.uint64 - i - 1]
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* _offset_.
*
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;uint64&#x27;);
* ref.<span class="apidocCodeKeywordSpan">writeUInt64BE</span>(buf, 0, &#x27;18446744073709551615&#x27;);
*
* var val = ref.readUInt64BE(buf, 0)
* console.log(val)
* &#x27;18446744073709551615&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ref.ref.writeUInt64LE" id="apidoc.element.ref.ref.writeUInt64LE">
        function <span class="apidocSignatureSpan">ref.ref.</span>writeUInt64LE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeUInt64() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* _offset_.
*
* If the returned value will fit inside a JavaScript Number without losing
* precision, then a Number is returned, otherwise a String is returned.
*
* ```
* var buf = ref.alloc(&#x27;uint64&#x27;);
* ref.<span class="apidocCodeKeywordSpan">writeUInt64LE</span>(buf, 0, &#x27;18446744073709551615&#x27;);
*
* var val = ref.readUInt64LE(buf, 0)
* console.log(val)
* &#x27;18446744073709551615&#x27;
* ```
*
* @param {Buffer} buffer The buffer to read a Buffer from.
...</pre></li>
    </ul>
















</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
